/* automatically generated by rust-bindgen 0.63.0 */

pub const ATTRIB_BLINK: u32 = 16;
pub const ATTRIB_REVERSE: u32 = 32;
pub const ATTRIB_UNDERLINE: u32 = 128;
pub const ATTRIB_HIGHLIGHT: u32 = 64;
pub const COLOUR_BLACK: u32 = 0;
pub const COLOUR_WHITE: u32 = 1;
pub const COLOUR_RED: u32 = 2;
pub const COLOUR_CYAN: u32 = 3;
pub const COLOUR_PURPLE: u32 = 4;
pub const COLOUR_GREEN: u32 = 5;
pub const COLOUR_BLUE: u32 = 6;
pub const COLOUR_YELLOW: u32 = 7;
pub const COLOUR_ORANGE: u32 = 8;
pub const COLOUR_BROWN: u32 = 9;
pub const COLOUR_PINK: u32 = 10;
pub const COLOUR_GREY1: u32 = 11;
pub const COLOUR_DARKGREY: u32 = 11;
pub const COLOUR_GREY2: u32 = 12;
pub const COLOUR_GREY: u32 = 12;
pub const COLOUR_MEDIUMGREY: u32 = 12;
pub const COLOUR_LIGHTGREEN: u32 = 13;
pub const COLOUR_LIGHTBLUE: u32 = 14;
pub const COLOUR_GREY3: u32 = 15;
pub const COLOUR_LIGHTGREY: u32 = 15;
pub const KEYMOD_RSHIFT: u32 = 1;
pub const KEYMOD_LSHIFT: u32 = 2;
pub const KEYMOD_CTRL: u32 = 4;
pub const KEYMOD_MEGA: u32 = 8;
pub const KEYMOD_ALT: u32 = 16;
pub const KEYMOD_NOSCRL: u32 = 32;
pub const KEYMOD_CAPSLOCK: u32 = 64;
pub const BOX_STYLE_NONE: u32 = 0;
pub const BOX_STYLE_INNER: u32 = 1;
pub const BOX_STYLE_MID: u32 = 2;
pub const BOX_STYLE_OUTER: u32 = 3;
pub const BOX_STYLE_ROUND: u32 = 4;
pub const HLINE_STYLE_TOP_THIN: u32 = 99;
pub const HLINE_STYLE_BTM_THIN: u32 = 100;
pub const HLINE_STYLE_TOP_NORMAL: u32 = 119;
pub const HLINE_STYLE_BTM_NORMAL: u32 = 111;
pub const HLINE_STYLE_TOP1_8: u32 = 69;
pub const HLINE_STYLE_TOP3_8: u32 = 68;
pub const HLINE_STYLE_BTM1_8: u32 = 82;
pub const HLINE_STYLE_BTM3_8: u32 = 70;
pub const HLINE_STYLE_MID: u32 = 64;
pub const HLINE_STYLE_CHECKER: u32 = 104;
pub const VLINE_STYLE_LEFT_NORMAL: u32 = 116;
pub const VLINE_STYLE_RIGHT_NORMAL: u32 = 106;
pub const VLINE_STYLE_MID: u32 = 66;
pub const VLINE_STYLE_CHECKER: u32 = 92;
pub const CINPUT_ACCEPT_NUMERIC: u32 = 1;
pub const CINPUT_ACCEPT_LETTER: u32 = 2;
pub const CINPUT_ACCEPT_ALL: u32 = 4;
pub const CINPUT_NO_AUTOTRANSLATE: u32 = 8;
pub const CINPUT_ACCEPT_ALPHA: u32 = 3;
pub const TARGET_UNKNOWN: u32 = 0;
pub const TARGET_MEGA65R1: u32 = 1;
pub const TARGET_MEGA65R2: u32 = 2;
pub const TARGET_MEGA65R3: u32 = 3;
pub const TARGET_MEGAPHONER1: u32 = 33;
pub const TARGET_MEGAPHONER4: u32 = 34;
pub const TARGET_NEXYS4: u32 = 64;
pub const TARGET_NEXYS4DDR: u32 = 65;
pub const TARGET_NEXYS4DDRWIDGET: u32 = 66;
pub const TARGET_WUKONG: u32 = 253;
pub const TARGET_SIMULATION: u32 = 254;
pub const TEST_START: u32 = 240;
pub const TEST_SKIP: u32 = 241;
pub const TEST_PASS: u32 = 242;
pub const TEST_FAIL: u32 = 243;
pub const TEST_ERROR: u32 = 244;
pub const TEST_LOG: u32 = 253;
pub const TEST_SETNAME: u32 = 254;
pub const TEST_DONEALL: u32 = 255;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagRECT {
    pub left: ::core::ffi::c_uchar,
    pub top: ::core::ffi::c_uchar,
    pub right: ::core::ffi::c_uchar,
    pub bottom: ::core::ffi::c_uchar,
}

pub type RECT = tagRECT;
extern "C" {
    #[doc = " \\m65libsummary{conionit}{Initialises the library internal state}\n\\m65libsyntax    {void conioinit(void)}\n\\m65libremarks{This must be called before using any conio library function.}"]
    pub fn conioinit();
}
extern "C" {
    #[doc = " \\m65libsummary{togglecase}{Set lower case character set}\n\\m65libsyntax    {void setlowercase(void)}"]
    pub fn setlowercase();
}
extern "C" {
    #[doc = " \\m65libsummary{togglecase}{Set upper case character set}\n\\m65libsyntax    {void setuppercase(void)}"]
    pub fn setuppercase();
}
extern "C" {
    #[doc = " \\m65libsummary{setscreenaddr}{Sets the screen RAM start address}\n\\m65libsyntax    {void setscreenaddr(long addr);}\n\\m65libparam     {addr}{The address to set as start of screen RAM}\n\\m65example   {\n// Set beginning of screen RAM at $48000\nsetscreenaddr(0x48000UL);\n}\n\\m65libremarks{No bounds check is performed on the selected address}"]
    pub fn setscreenaddr(addr: ::core::ffi::c_long);
}
extern "C" {
    #[doc = " \\m65libsummary{getscreenaddr}{Returns the screen RAM start address}\n\\m65libsyntax    {long getscreenaddr(void);}\n\\m65libretval    {The current screen RAM address start address.}"]
    pub fn getscreenaddr() -> ::core::ffi::c_long;
}
extern "C" {
    #[doc = " \\m65libsummary{setcolramoffset}{Sets the color RAM start offset value}\n\\m65libsyntax    {void setcolramoffset(long offset);}\n\\m65libparam     {addr}{The offset from the beginning of the color RAM address ($FF80000)}\n\\m65libremarks{No bounds check is performed on the resulting address. Do not exceed the available Color RAM size}"]
    pub fn setcolramoffset(addr: ::core::ffi::c_uint);
}
extern "C" {
    #[doc = " \\m65libsummary{getcolramoffset}{Returns the color RAM start offset value}\n\\m65libsyntax    {long getscreenaddr(void);}\n\\m65libretval    {The current color RAM start offset value.}"]
    pub fn getcolramoffset() -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " \\m65libsummary{setcharsetaddr}{Sets the character set start address}\n\\m65libsyntax    {void setcharsetaddr(long addr);}\n\\m65libparam     {addr}{The address to set as start of character set}\n\\m65libremarks   {No bounds check is performed on the selected address}"]
    pub fn setcharsetaddr(addr: ::core::ffi::c_long);
}
extern "C" {
    #[doc = " \\m65libsummary{getcharsetaddr}{Returns the current character set start address}\n\\m65libsyntax    {long getscreenaddr(void);}\n\\m65libretval    {The current character set start address.}"]
    pub fn getcharsetaddr() -> ::core::ffi::c_long;
}
extern "C" {
    #[doc = "\\m65libsummary{clrscr}{Clear the text screen. }\n\\m65libsyntax    {void clrscr(void)}\n\\m65example   {\n// Clear screen to white\ntextcolor(COLOUR_WHITE);\nclrscr();\n}\n\\m65libremarks{Color RAM will be cleared with current text color}"]
    pub fn clrscr();
}
extern "C" {
    #[doc = " \\m65libsummary{getscreensize}{Returns the dimensions of the text screen}\n\\m65libsyntax    {void getscreensize(unsigned char* width, unsigned char* height)}\n\\m65libparam     {width}{Pointer to location where width will be returned}\n\\m65libparam     {height}{Pointer to location where height will be returned}"]
    pub fn getscreensize(width: *mut ::core::ffi::c_uchar, height: *mut ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{setscreensize}{Sets the dimensions of the text screen}\n\\m65libsyntax    {void setscreensize(unsigned char width, unsigned char height)}\n\\m65libparam     {width}{The width in columns (40 or 80)}\n\\m65libparam     {height}{The height in rows (25 or 50)}\n\\m65libremarks   {Currently only 40/80 and 25/50 are accepted. Other values are ignored.}"]
    pub fn setscreensize(width: ::core::ffi::c_uchar, height: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{set16bitcharmode}{Sets or clear the 16-bit character mode}\n\\m65libsyntax    {void set16bitcharmode(unsigned char f)}\n\\m65libparam     {f}{Set true to set the 16-bit character mode}\n\\m65libremarks   {This will trigger a video parameter reset if HOTREG is ENABLED. See sethotregs function.}"]
    pub fn set16bitcharmode(f: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{sethotregs}{Sets or clear the hot-register behavior of the VIC-IV chip.}\n\\m65libsyntax    {void set16bitcharmode(unsigned char f)}\n\\m65libparam     {f}{Set true to enable the hotreg behavior}\n\\m65libremarks   {When this mode is ENABLED a video mode reset will be triggered when touching $D011, $D016, $D018, $D031\nor the VIC-II bank bits of $DD00. }"]
    pub fn sethotregs(f: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{setextendedattrib}{Sets or clear the VIC-III extended attributes mode to support blink, underline, bold\nand highlight.} \\m65libsyntax    {void setextendedattrib(unsigned char f)} \\m65libparam     {f}{Set true to set the\nextended attributes mode}"]
    pub fn setextendedattrib(f: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{togglecase}{Toggle the current character set case}\n\\m65libsyntax    {void togglecase(void)}"]
    pub fn togglecase();
}
extern "C" {
    #[doc = " \\m65libsummary{bordercolor}{Sets the current border color}\n\\m65libsyntax    {void bordercolor(unsigned char c)}\n\\m65libparam     {c}{The color to set}"]
    pub fn bordercolor(c: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{bgcolor}{Sets the current screen (background) color}\n\\m65libsyntax    {void bgcolor(unsigned char c)}\n\\m65libparam     {c}{The color to set}"]
    pub fn bgcolor(c: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{textcolor}{Sets the current text color}\n\\m65libsyntax    {void textcolor(unsigned char c)}\n\\m65libparam     {c}{The color to set}\n\\m65libremarks   {This function preserves attributes in the upper 4-bits if extended attributes are enabled. See\nsetextendedattrib. }"]
    pub fn textcolor(c: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{revers}{Enable the reverse attribute}\n\\m65libsyntax    {void revers(unsigned char c)}\n\\m65libparam     {enable}{0 to disable, 1 to enable}\n\\m65libremarks   {Extended attributes mode must be active. See setextendedattrib.}"]
    pub fn revers(enable: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{highlight}{Enable the highlight attribute}\n\\m65libsyntax    {void highlight(unsigned char c)}\n\\m65libparam     {enable}{0 to disable, 1 to enable}\n\\m65libremarks   {Extended attributes mode must be active. See setextendedattrib.}"]
    pub fn highlight(enable: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{blink}{Enable the blink attribute}\n\\m65libsyntax    {void blink(unsigned char c)}\n\\m65libparam     {enable}{0 to disable, 1 to enable}\n\\m65libremarks   {Extended attributes mode must be active. See setextendedattrib.}"]
    pub fn blink(enable: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{underline}{Enable the underline attribute}\n\\m65libsyntax    {void underline(unsigned char c)}\n\\m65libparam     {enable}{0 to disable, 1 to enable}\n\\m65libremarks   {Extended attributes mode must be active. See setextendedattrib.}"]
    pub fn underline(enable: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{altpal}{Enable the alternate-palette attribute}\n\\m65libsyntax    {void altpal(unsigned char c)}\n\\m65libparam     {enable}{0 to disable, 1 to enable}\n\\m65libremarks   {Extended attributes mode must be active. See setextendedattrib.}"]
    pub fn altpal(enable: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{clearattr}{Clear all text attributes}\n\\m65libsyntax    {void clearattr())}\n\\m65libremarks   {Extended attributes mode must be active. See setextendedattrib.}"]
    pub fn clearattr();
}
extern "C" {
    #[doc = " \\m65libsummary{cellcolor}{Sets the color of a character cell}\n\\m65libsyntax    {void cellcolor(unsigned char x, unsigned char y, unsigned char c)}\n\\m65libparam     {x}{The cell X-coordinate}\n\\m65libparam     {y}{The cell Y-coordinate}\n\\m65libparam     {c}{The color to set}\n\\m65libremarks   {No screen bounds checks are performed; out of screen behavior is undefined }"]
    pub fn cellcolor(x: ::core::ffi::c_uchar, y: ::core::ffi::c_uchar, c: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{setpalbank}{Set current text/bitmap palette bank (BTPALSEL).}\n\\m65libsyntax    {void setpalbank(unsigned char bank)}\n\\m65libparam     {bank}{The palette bank to set. Valid values are 0, 1, 2 or 3.}\n\\m65libremarks   {Use setpalbanka to set alternate text/bitmap palette}"]
    pub fn setpalbank(bank: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{setpalbanka}{Set alternate text/bitmap palette bank.}\n\\m65libsyntax    {void setpalbanka(unsigned char bank)}\n\\m65libparam     {bank}{The palette bank to set. Valid values are 0, 1, 2 or 3.}\n\\m65libremarks   {Use setpalbank to set main text/bitmap palette}"]
    pub fn setpalbanka(bank: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{getpalbank}{Get selected text/bitmap palette bank.}\n\\m65libsyntax    {unsigned char getpalbank(void)}\n\\m65libremarks   {Use getpalbanka to get alternate text/bitmap selected palette}\n\\m65libretval    {The current selected main text/bitmap palette bank.}"]
    pub fn getpalbank() -> ::core::ffi::c_uchar;
}
extern "C" {
    #[doc = " \\m65libsummary{getpalbanka}{Get selected alternate text/bitmap palette bank.}\n\\m65libsyntax    {unsigned char getpalbanka(void)}\n\\m65libremarks   {Use getpalbank to get main text/bitmap selected palette}\n\\m65libretval    {The current selected alternate text/bitmap palette bank.}"]
    pub fn getpalbanka() -> ::core::ffi::c_uchar;
}
extern "C" {
    #[doc = " \\m65libsummary{setmapedpal}{Set maped-in palette bank at $D100-$D3FF.}\n\\m65libsyntax    {void setmapedpal(unsigned char bank)}\n\\m65libparam     {bank}{The palette bank to map-in. Valid values are 0, 1, 2 or 3.}"]
    pub fn setmapedpal(bank: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{getmapedpal}{Get maped-in  palette bank at $D100-$D3FF.}\n\\m65libsyntax    {unsigned char getmapedpal(void)}"]
    pub fn getmapedpal() -> ::core::ffi::c_uchar;
}
extern "C" {
    #[doc = " \\m65libsummary{setpalentry}{Set color entry for the maped-in palette}\n\\m65libsyntax    {void setpalentry(unsigned char c, unsigned char r, unsigned char g, unsigned char b)}\n\\m65libparam     {c}{The palette entry index (0-255)}\n\\m65libparam     {r}{The red component value}\n\\m65libparam     {g}{The green component value}\n\\m65libparam     {b}{The blue component value}\n\\m65libremarks   {Use setmapedmal to bank-in the palette to modify}"]
    pub fn setpalentry(
        c: ::core::ffi::c_uchar,
        r: ::core::ffi::c_uchar,
        g: ::core::ffi::c_uchar,
        b: ::core::ffi::c_uchar,
    );
}
extern "C" {
    #[doc = " \\m65libsummary{fillrect}{Fill a rectangular area with character and color value}\n\\m65libsyntax    {void fillrect(const RECT *rc, unsigned char ch, unsigned char col)}\n\\m65libparam     {rc}{A RECT structure specifying the box coordinates}\n\\m65libparam     {ch}{A char code to fill the rectangle}\n\\m65libparam     {col}{The color to fill}\n\\m65libremarks   {No screen bounds checks are performed; out of screen behavior is undefined }"]
    pub fn fillrect(rc: *const RECT, ch: ::core::ffi::c_uchar, col: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{box}{Draws a box with graphic characters}\n\\m65libsyntax    {void box(const RECT *rc, unsigned char color, unsigned char style, unsigned char clear, unsigned char\nshadow)} \\m65libparam     {rc}{A RECT structure specifying the box coordinates} \\m65libparam     {color}{The color to use\nfor the graphic characters} \\m65libparam     {style}{The style for the box borders. Can be set to BOX_STYLE_NONE,\nBOX_STYLE_ROUNDED, BOX_STYLE_INNER, BOX_STYLE_OUTER, BOX_STYLE_MID } \\m65libparam     {clear}{Set to 1 to clear the box\ninterior with the selected color} \\m65libparam     {shadow}{Set to 1 to draw a drop shadow} \\m65libremarks   {No screen\nbounds checks are performed; out of screen behavior is undefined }"]
    #[link_name = "\u{1}box"]
    pub fn box_(
        rc: *const RECT,
        color: ::core::ffi::c_uchar,
        style: ::core::ffi::c_uchar,
        clear: ::core::ffi::c_uchar,
        shadow: ::core::ffi::c_uchar,
    );
}
extern "C" {
    #[doc = " \\m65libsummary{hline}{Draws an horizontal line.}\n\\m65libsyntax    {void hline(unsigned char x, unsigned char y, unsigned char len, unsigned char style)}\n\\m65libparam     {x}{The line start X-coordinate}\n\\m65libparam     {y}{The line start Y-coordinate}\n\\m65libparam     {len}{The line length}\n\\m65libparam     {style}{The style for the line. See HLINE_ constants for available styles. }\n\\m65libremarks   {No screen bounds checks are performed; out of screen behavior is undefined }"]
    pub fn hline(
        x: ::core::ffi::c_uchar,
        y: ::core::ffi::c_uchar,
        len: ::core::ffi::c_uchar,
        style: ::core::ffi::c_uchar,
    );
}
extern "C" {
    #[doc = " \\m65libsummary{vline}{Draws a vertical line.}\n\\m65libsyntax    {void vline(unsigned char x, unsigned char y, unsigned char len, unsigned char style)}\n\\m65libparam     {x}{The line start X-coordinate}\n\\m65libparam     {y}{The line start Y-coordinate}\n\\m65libparam     {len}{The line length}\n\\m65libparam     {style}{The style for the line. See VLINE_ constants for available styles. }\n\\m65libremarks   {No screen bounds checks are performed; out of screen behavior is undefined }"]
    pub fn vline(
        x: ::core::ffi::c_uchar,
        y: ::core::ffi::c_uchar,
        len: ::core::ffi::c_uchar,
        style: ::core::ffi::c_uchar,
    );
}
extern "C" {
    #[doc = " \\m65libsummary{gohome}{Set the current position at home (0,0 coordinate)}\n\\m65libsyntax    {void gohome(void)}"]
    pub fn gohome();
}
extern "C" {
    #[doc = " \\m65libsummary{gotoxy}{Set the current position at X,Y coordinates}\n\\m65libsyntax    {void gotoxy(unsigned char x, unsigned char y)}\n\\m65libparam     {x}{The new X-coordinate}\n\\m65libparam     {y}{The new Y-coordinate}\n\\m65libremarks   {No screen bounds checks are performed; out of screen behavior is undefined }"]
    pub fn gotoxy(x: ::core::ffi::c_uchar, y: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{gotox}{Set the current position X-coordinate}\n\\m65libsyntax    {void gotox(unsigned char x)}\n\\m65libparam     {x}{The new X-coordinate}\n\\m65libremarks   {No screen bounds checks are performed; out of screen behavior is undefined }"]
    pub fn gotox(x: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{gotoy}{Set the current position Y-coordinate}\n\\m65libsyntax    {void gotoy(unsigned char y)}\n\\m65libparam     {y}{The new Y-coordinate}\n\\m65libremarks   {No screen bounds checks are performed; out of screen behavior is undefined }"]
    pub fn gotoy(y: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{moveup}{Move current position up}\n\\m65libsyntax    {void moveup(unsigned char count)}\n\\m65libparam     {count}{The number of positions to move}\n\\m65libremarks   {No screen bounds checks are performed; out of screen behavior is undefined }"]
    pub fn moveup(count: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{movedown}{Move current position down}\n\\m65libsyntax    {void movedown(unsigned char count)}\n\\m65libparam     {count}{The number of positions to move}\n\\m65libremarks   {No screen bounds checks are performed; out of screen behavior is undefined }"]
    pub fn movedown(count: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{moveleft}{Move current position left}\n\\m65libsyntax    {void moveleft(unsigned char count)}\n\\m65libparam     {count}{The number of positions to move}\n\\m65libremarks   {No screen bounds checks are performed; out of screen behavior is undefined }"]
    pub fn moveleft(count: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{moveright}{Move current position right}\n\\m65libsyntax    {void moveright(unsigned char count)}\n\\m65libparam     {count}{The number of positions to move}\n\\m65libremarks   {No screen bounds checks are performed; out of screen behavior is undefined }"]
    pub fn moveright(count: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{wherex}{Return the current position X coordinate}\n\\m65libsyntax    {unsigned char wherex(void)}\n\\m65libretval    {The current position X coordinate}"]
    pub fn wherex() -> ::core::ffi::c_uchar;
}
extern "C" {
    #[doc = " \\m65libsummary{wherey}{Return the current position Y coordinate}\n\\m65libsyntax    {unsigned char wherey(void)}\n\\m65libretval    {The current position Y coordinate}"]
    pub fn wherey() -> ::core::ffi::c_uchar;
}
extern "C" {
    pub fn petsciitoscreencode(c: ::core::ffi::c_char) -> ::core::ffi::c_char;
}
extern "C" {
    pub fn petsciitoscreencode_s(s: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = " \\m65libsummary{cputc}{Output a single screen code character to screen at current position}\n\\m65libsyntax    {void cputc(unsigned char c)}\n\\m65libparam     {c}{The screen code of the character to output}"]
    pub fn cputc(c: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{cputnc}{Output N copies of a character at current position}\n\\m65libsyntax    {void cputnc(unsigned char count, unsigned char c)}\n\\m65libparam     {c}{The screen code of the characters to output}\n\\m65libparam     {count}{The count of characters to print}"]
    pub fn cputnc(count: ::core::ffi::c_uchar, c: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{cputhex}{Output an hex-formatted number at current position}\n\\m65libsyntax    {void cputhex(long n, unsigned char prec)}\n\\m65libparam     {n}{The number to write}\n\\m65libparam     {prec}{The precision of the hex number, in digits. Leading zeros will be printed accordingly}\n\\m65libremarks   {The $ symbol will be automatically added at beginning of string}"]
    pub fn cputhex(n: ::core::ffi::c_long, prec: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{cputdec}{Output a decimal number at current position}\n\\m65libsyntax    {void cputdec(long n, unsigned char padding, unsigned char leadingZ)}\n\\m65libparam     {n}{The number to write}\n\\m65libparam     {padding}{The padding space to add before number}\n\\m65libparam     {leadingZ}{The leading zeros to print}"]
    pub fn cputdec(
        n: ::core::ffi::c_long,
        padding: ::core::ffi::c_uchar,
        leadingZ: ::core::ffi::c_uchar,
    );
}
extern "C" {
    #[doc = " \\m65libsummary{cputs}{Output screen codes at current position}\n\\m65libsyntax    {void cputs(const unsigned char* s)}\n\\m65libparam     {s}{Am array of screen codes to print}\n\\m65libremarks   {This function works with screen codes only. To output ordinary ASCII/PETSCII strings,\nuse the \"pcputs\" macro. No pointer check is performed.  If s is null or invalid, behavior is undefined. }"]
    pub fn cputs(s: *const ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{cputsxy}{Output multiple screen codes at X,Y coordinates}\n\\m65libsyntax    {void cputsxy (unsigned char x, unsigned char y, const unsigned char* s)}\n\\m65libparam     {x}{The X coordinate where string will be printed}\n\\m65libparam     {y}{The Y coordinate where string will be printed}\n\\m65libparam     {s}{An array of screen codes to print}\n\\m65libremarks   {This function works with screen codes only. To output ordinary ASCII/PETSCII strings,\nuse the \"pcputsxy\" macro. No pointer check is performed.  If s is null or invalid, behavior is undefined. }"]
    pub fn cputsxy(
        x: ::core::ffi::c_uchar,
        y: ::core::ffi::c_uchar,
        s: *const ::core::ffi::c_uchar,
    );
}
extern "C" {
    #[doc = " \\m65libsummary{cputcxy}{Output a single character at X,Y coordinates}\n\\m65libsyntax    {void cputcxy (unsigned char x, unsigned char y, unsigned char c)}\n\\m65libparam     {x}{The X coordinate where character will be printed}\n\\m65libparam     {y}{The Y coordinate where character will be printed}\n\\m65libparam     {c}{The screen code of the character to print}"]
    pub fn cputcxy(x: ::core::ffi::c_uchar, y: ::core::ffi::c_uchar, c: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{cputncxy}{Output N copies of a single character at X,Y coordinates}\n\\m65libsyntax    {void cputncxy (unsigned char x, unsigned char y, unsigned char count, unsigned char c)}\n\\m65libparam     {x}{The X coordinate where character will be printed}\n\\m65libparam     {y}{The Y coordinate where character will be printed}\n\\m65libparam     {count}{The number of characters to output}\n\\m65libparam     {c}{The screen code of the characters to print}"]
    pub fn cputncxy(
        x: ::core::ffi::c_uchar,
        y: ::core::ffi::c_uchar,
        count: ::core::ffi::c_uchar,
        c: ::core::ffi::c_uchar,
    );
}
extern "C" {
    pub fn _cprintf(
        translateCodes: ::core::ffi::c_uchar,
        fmt: *const ::core::ffi::c_uchar,
        ...
    ) -> ::core::ffi::c_uchar;
}
extern "C" {
    #[doc = " \\m65libsummary{cgetc}{ Waits until a character is in the keyboard buffer and returns it }\n\\m65libsyntax    {unsigned char cgetc (void);}\n\\m65libretval    {The last character in the keyboard buffer }\n\\m65libremarks   {Returned values are ASCII character codes}"]
    pub fn cgetc() -> ::core::ffi::c_uchar;
}
extern "C" {
    #[doc = " \\m65libsummary{kbhit}{ Returns the character in the keyboard buffer }\n\\m65libsyntax    {unsigned char kbhit (void);}\n\\m65libretval    {The character code in the keyboard buffer,  0 otherwise. }\n\\m65libremarks   {Returned values are ASCII character codes}"]
    pub fn kbhit() -> ::core::ffi::c_uchar;
}
extern "C" {
    #[doc = " \\m65libsummary{getkeymodstate}{\nReturn the key modifiers state.}\n\\m65libsyntax    {unsigned char getkeymodstate(void)}\n\\m65libretval    {A byte with the key modifier state bits,\nwhere bits:\n%<\n\\begin{tabular}{lll}\n\\textbf{Bit} & \\textbf{Meaning} & \\textbf{Constant}        \\\\\n0   & Right SHIFT State & \\texttt{KEYMOD\\_RSHIFT} \\\\\n1   & Left  SHIFT state & \\texttt{KEYMOD\\_LSHIFT} \\\\\n2   & CTRL state        & \\texttt{KEYMOD\\_CTRL}  \\\\\n3   & MEGA state        & \\texttt{KEYMOD\\_MEGA} \\\\\n4   & ALT state         & \\texttt{KEYMOD\\_ALT} \\\\\n5   & NOSCRL state      & \\texttt{KEYMOD\\_NOSCRL} \\\\\n6   & CAPSLOCK state    & \\texttt{KEYMOD\\_CAPSLOCK} \\\\\n7   & Reserved          & - \\\\\n\\end{tabular}\n%>}"]
    pub fn getkeymodstate() -> ::core::ffi::c_uchar;
}
extern "C" {
    #[doc = " \\m65libsummary{flushkeybuf}{Flush the keyboard buffer}\n\\m65libsyntax    {void flushkeybuf(void)}"]
    pub fn flushkeybuf();
}
extern "C" {
    #[doc = " \\m65libsummary{cinput}{Get input from keyboard, printing incoming characters at current position.}\n\\m65libsyntax    {unsigned char cinput(char* buffer, unsigned char buflen, unsigned char flags)}\n\\m65libparam     {buffer}{Target character buffer preallocated by caller}\n\\m65libparam     {buflen}{Target buffer length in characters, including the null character terminator}\n\\m65libparam     {flags}{Flags for input:  (default is accept all printable characters)\n%<\n\\texttt{CINPUT\\_ACCEPT\\_NUMERIC} \\\\\nAccepts numeric characters. \\\\ \\\\\n\\texttt{CINPUT\\_ACCEPT\\_LETTER}  \\\\\nAccepts letters.  \\\\ \\\\\n\\texttt{CINPUT\\_ACCEPT\\_SYM}  \\\\\nAccepts symbols.  \\\\ \\\\\n\\texttt{CINPUT\\_ACCEPT\\_ALL}\\\\\nAccepts all. Equals to \\texttt{CINPUT\\_ACCEPT\\_NUMERIC \\textbar CINPUT\\_ACCEPT\\_LETTER \\textbar\nCINPUT\\_ACCEPT\\_SYM} \\\\ \\\\\n\\texttt{CINPUT\\_ACCEPT\\_ALPHA} \\\\\nAccepts alphanumeric characters. Equals to \\texttt{CINPUT\\_ACCEPT\\_NUMERIC \\textbar CINPUT\\_ACCEPT\\_LETTER} \\\\ \\\\\n\\texttt{CINPUT\\_NO\\_AUTOTRANSLATE}\\\\\nDisables the feature that makes cinput to autodisplay uppercase characters when standard lowercase character set\nis selected  and the user enters letters without the SHIFT key, that would display graphic characters instead of\nalphabetic ones. \\\\\n%>}\n\n\\m65libretval    {Count of successfully read characters in buffer}"]
    pub fn cinput(
        buffer: *mut ::core::ffi::c_uchar,
        buflen: ::core::ffi::c_uchar,
        flags: ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_uchar;
}
extern "C" {
    pub fn debug_msg(m: *mut ::core::ffi::c_char);
}
pub type int_least64_t = i64;
pub type uint_least64_t = u64;
pub type int_fast64_t = i64;
pub type uint_fast64_t = u64;
pub type int_least32_t = i32;
pub type uint_least32_t = u32;
pub type int_fast32_t = i32;
pub type uint_fast32_t = u32;
pub type int_least16_t = i16;
pub type uint_least16_t = u16;
pub type int_fast16_t = i16;
pub type uint_fast16_t = u16;
pub type int_least8_t = i8;
pub type uint_least8_t = u8;
pub type int_fast8_t = i8;
pub type uint_fast8_t = u8;
pub type intmax_t = ::core::ffi::c_longlong;
pub type uintmax_t = ::core::ffi::c_ulonglong;
extern "C" {
    pub fn opendir() -> ::core::ffi::c_uchar;
}
extern "C" {
    pub fn readdir(arg1: ::core::ffi::c_uchar) -> *mut m65_dirent;
}
extern "C" {
    pub fn closedir(arg1: ::core::ffi::c_uchar);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct m65_dirent {
    pub d_ino: u32,
    pub d_off: u16,
    pub d_reclen: u32,
    pub d_type: u16,
    pub d_name: [::core::ffi::c_char; 256usize],
}
impl Default for m65_dirent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn toggle_rom_write_protect();
}
extern "C" {
    pub fn closeall();
}
extern "C" {
    pub fn close(fd: ::core::ffi::c_uchar);
}
extern "C" {
    pub fn open(filename: *const ::core::ffi::c_char) -> ::core::ffi::c_uchar;
}
extern "C" {
    pub fn read512(buffer: *mut ::core::ffi::c_uchar) -> ::core::ffi::c_ushort;
}
extern "C" {
    pub fn chdir(filename: *const ::core::ffi::c_char) -> ::core::ffi::c_uchar;
}
extern "C" {
    pub fn chdirroot() -> ::core::ffi::c_uchar;
}
extern "C" {
    pub fn usleep(micros: u32);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dmagic_dmalist {
    pub option_0b: ::core::ffi::c_uchar,
    pub option_80: ::core::ffi::c_uchar,
    pub source_mb: ::core::ffi::c_uchar,
    pub option_81: ::core::ffi::c_uchar,
    pub dest_mb: ::core::ffi::c_uchar,
    pub option_85: ::core::ffi::c_uchar,
    pub dest_skip: ::core::ffi::c_uchar,
    pub end_of_options: ::core::ffi::c_uchar,
    pub command: ::core::ffi::c_uchar,
    pub count: ::core::ffi::c_uint,
    pub source_addr: ::core::ffi::c_uint,
    pub source_bank: ::core::ffi::c_uchar,
    pub dest_addr: ::core::ffi::c_uint,
    pub dest_bank: ::core::ffi::c_uchar,
    pub sub_cmd: ::core::ffi::c_uchar,
    pub modulo: ::core::ffi::c_uint,
}
extern "C" {
    pub static mut dmalist: dmagic_dmalist;
}
extern "C" {
    pub static mut dma_byte: ::core::ffi::c_uchar;
}
extern "C" {
    pub fn mega65_io_enable();
}
extern "C" {
    pub fn lpeek(address: ::core::ffi::c_long) -> ::core::ffi::c_uchar;
}
extern "C" {
    pub fn lpeek_debounced(address: ::core::ffi::c_long) -> ::core::ffi::c_uchar;
}
extern "C" {
    pub fn lpoke(address: ::core::ffi::c_long, value: ::core::ffi::c_uchar);
}
extern "C" {
    pub fn lcopy(
        source_address: ::core::ffi::c_long,
        destination_address: ::core::ffi::c_long,
        count: ::core::ffi::c_uint,
    );
}
extern "C" {
    pub fn lfill(
        destination_address: ::core::ffi::c_long,
        value: ::core::ffi::c_uchar,
        count: ::core::ffi::c_uint,
    );
}
extern "C" {
    pub fn lfill_skip(
        destination_address: ::core::ffi::c_long,
        value: ::core::ffi::c_uchar,
        count: ::core::ffi::c_uint,
        skip: ::core::ffi::c_uchar,
    );
}
extern "C" {
    pub fn random32(range: u32) -> u32;
}
extern "C" {
    pub fn random16(range: u16) -> u16;
}
extern "C" {
    pub fn random8(range: u8) -> u8;
}
extern "C" {
    pub fn srand(seed: u32);
}
extern "C" {
    pub fn rand8(range: u8) -> u8;
}
extern "C" {
    pub fn rand16(range: u16) -> u16;
}
extern "C" {
    pub fn rand32(range: u32) -> u32;
}
extern "C" {
    pub static mut sector_buffer: [u8; 512usize];
}
extern "C" {
    pub fn mega65_clear_sector_buffer();
}
extern "C" {
    pub fn mega65_sdcard_reset();
}
extern "C" {
    pub fn mega65_fast();
}
extern "C" {
    pub fn mega65_sdcard_open();
}
extern "C" {
    pub fn mega65_sdcard_map_sector_buffer();
}
extern "C" {
    pub fn mega65_sdcard_unmap_sector_buffer();
}
extern "C" {
    pub fn mega65_sdcard_readsector(sector_number: u32) -> u8;
}
extern "C" {
    pub fn mega65_sdcard_writesector(sector_number: u32) -> u8;
}
extern "C" {
    pub fn mega65_sdcard_erase(first_sector: u32, last_sector: u32);
}
extern "C" {
    pub fn detect_target() -> ::core::ffi::c_uchar;
}
extern "C" {
    #[doc = " \\brief Setup of the unit test reporting to the host machine\n \\param param testName Human readable name of the test\n \\param issueNum The mega65-core issue number that identifies the test issue"]
    pub fn unit_test_setup(testName: *mut ::core::ffi::c_char, issueNum: ::core::ffi::c_ushort);
}
extern "C" {
    #[doc = " \\brief Report a successful test with a optional message\n \\param msg Description of the successful test (NULL uses global testName)"]
    pub fn unit_test_ok(msg: *mut ::core::ffi::c_char);
}
extern "C" {
    #[doc = " \\brief Report a failed test with a optional message\n \\param msg Description of the failed test (NULL uses global testName)"]
    pub fn unit_test_fail(msg: *mut ::core::ffi::c_char);
}
extern "C" {
    #[doc = " \\brief Finish test procedure and tell m65 to exit"]
    pub fn unit_test_done();
}
extern "C" {
    #[doc = " \\brief Reports unit test result to the host machine\n \\param issue The issue number that identifies the test issue\n \\param sub The sub issue number (for multiple tests per issue)\n \\param status The test status to be sent"]
    pub fn unit_test_report(
        issue: ::core::ffi::c_ushort,
        sub: ::core::ffi::c_uchar,
        status: ::core::ffi::c_uchar,
    );
}
extern "C" {
    #[doc = " \\brief Reports current test name to the host machine\n \\param name The human-readable name of the current test"]
    pub fn unit_test_set_current_name(name: *mut ::core::ffi::c_char);
}
extern "C" {
    #[doc = " \\brief Logs a message on the host machine\n \\param msg The message to be logged"]
    pub fn unit_test_log(msg: *mut ::core::ffi::c_char);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct m65_tm {
    pub tm_sec: ::core::ffi::c_uchar,
    pub tm_min: ::core::ffi::c_uchar,
    pub tm_hour: ::core::ffi::c_uchar,
    pub tm_mday: ::core::ffi::c_uchar,
    pub tm_mon: ::core::ffi::c_uchar,
    pub tm_year: ::core::ffi::c_ushort,
    pub tm_wday: ::core::ffi::c_uchar,
    pub tm_yday: ::core::ffi::c_int,
    pub tm_isdst: ::core::ffi::c_uchar,
}
extern "C" {
    pub fn getrtc(tm: *mut m65_tm);
}
extern "C" {
    pub fn setrtc(tm: *mut m65_tm);
}
